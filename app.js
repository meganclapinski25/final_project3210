// app.js
import express from 'express';
import http from 'http';
import { Server } from 'socket.io';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
const server = http.createServer(app);
const io = new Server(server);

app.use(express.static(path.join(__dirname, 'public')));

// --- Simple matchmaker + game state ---
const WAITING = [];               // sockets waiting for a match
const ROOMS = new Map();          // roomId -> game state

const BOARD_SIZE = 10;
const SHIPS = [
  { name: 'carrier', len: 5 },
  { name: 'battleship', len: 4 },
  { name: 'cruiser', len: 3 },
  { name: 'submarine', len: 3 },
  { name: 'destroyer', len: 2 },
];

// Helpers
function emptyBoard() {
  return Array.from({ length: BOARD_SIZE }, () =>
    Array.from({ length: BOARD_SIZE }, () => 0)
  );
}
function inBounds(r, c) {
  return r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE;
}
function tryPlace(board, len, row, col, dr, dc) {
  const coords = [];
  for (let i = 0; i < len; i++) {
    const r = row + dr * i;
    const c = col + dc * i;
    if (!inBounds(r, c) || board[r][c] !== 0) return null;
    coords.push([r, c]);
  }
  coords.forEach(([r, c]) => (board[r][c] = len)); // mark with ship length
  return coords;
}
function randomPlaceAllShips() {
  const board = emptyBoard();
  const placements = {};
  for (const ship of SHIPS) {
    let placed = null;
    for (let attempt = 0; attempt < 500 && !placed; attempt++) {
      const vertical = Math.random() < 0.5;
      const dr = vertical ? 1 : 0;
      const dc = vertical ? 0 : 1;
      const r = Math.floor(Math.random() * BOARD_SIZE);
      const c = Math.floor(Math.random() * BOARD_SIZE);
      const coords = tryPlace(board, ship.len, r, c, dr, dc);
      if (coords) {
        placements[ship.name] = coords;
        placed = true;
      }
    }
    if (!placed) throw new Error('Failed to place ships');
  }
  return { board, placements };
}

function countRemaining(board, hits) {
  // Remaining ship cells = cells with value > 0 and not yet hit
  let total = 0;
  for (let r = 0; r < BOARD_SIZE; r++) {
    for (let c = 0; c < BOARD_SIZE; c++) {
      if (board[r][c] > 0 && !hits.has(`${r},${c}`)) total++;
    }
  }
  return total;
}

// Create a new match/room with two sockets
function createRoom(p1, p2) {
  const roomId = `room-${p1.id}-${p2.id}`;
  p1.join(roomId);
  p2.join(roomId);

  // Boards generated by server (no manual placement to keep it simple)
  const A = randomPlaceAllShips();
  const B = randomPlaceAllShips();

  const state = {
    roomId,
    players: [p1.id, p2.id],              // player 0 and player 1
    boards: [A.board, B.board],           // secret boards
    hits: [new Set(), new Set()],         // coords like "r,c"
    misses: [new Set(), new Set()],
    turn: 0,                              // index of current player
    over: false
  };

  ROOMS.set(roomId, state);

  io.to(roomId).emit('start', {
    roomId,
    youAre: { [p1.id]: 0, [p2.id]: 1 },   // client figures out index
    boardSize: BOARD_SIZE,
    ships: SHIPS.map(s => ({ name: s.name, len: s.len })),
  });

  // DM each player their own ships (for display)
  io.to(p1.id).emit('your-ships', A.placements);
  io.to(p2.id).emit('your-ships', B.placements);

  io.to(roomId).emit('turn', { playerIndex: state.turn });
}

io.on('connection', (socket) => {
  // Simple username for display (optional)
  socket.on('hello', (name) => {
    socket.data.name = (name && name.trim()) || `Player-${socket.id.slice(0,4)}`;
  });

  // Queue for match
  socket.on('find-match', () => {
    if (WAITING.includes(socket)) return;
    WAITING.push(socket);
    if (WAITING.length >= 2) {
      const p1 = WAITING.shift();
      const p2 = WAITING.shift();
      createRoom(p1, p2);
    } else {
      socket.emit('status', 'Waiting for an opponentâ€¦');
    }
  });

  // Fire at opponent
  socket.on('fire', ({ roomId, row, col }) => {
    const state = ROOMS.get(roomId);
    if (!state || state.over) return;

    const me = state.players.indexOf(socket.id);
    if (me === -1) return;

    if (state.turn !== me) {
      socket.emit('status', 'Not your turn!');
      return;
    }

    const opp = 1 - me;
    const targetBoard = state.boards[opp];
    const key = `${row},${col}`;

    // prevent re-firing same cell
    if (state.hits[me].has(key) || state.misses[me].has(key)) {
      socket.emit('status', 'Already fired there.');
      return;
    }

    let result = 'miss';
    if (inBounds(row, col) && targetBoard[row][col] > 0) {
      state.hits[me].add(key);
      result = 'hit';
    } else {
      state.misses[me].add(key);
    }

    // Notify both players about the shot result
    io.to(roomId).emit('fire-result', {
      shooter: me,
      row, col, result
    });

    // Check win
    const remaining = countRemaining(targetBoard, state.hits[me]);
    if (remaining === 0) {
      state.over = true;
      io.to(roomId).emit('game-over', { winner: me });
      return;
    }

    // Next turn
    state.turn = opp;
    io.to(roomId).emit('turn', { playerIndex: state.turn });
  });

  socket.on('disconnect', () => {
    // Clean up waiting list
    const idx = WAITING.indexOf(socket);
    if (idx !== -1) WAITING.splice(idx, 1);

    // If in a room, announce forfeit
    for (const [roomId, state] of ROOMS) {
      const i = state.players.indexOf(socket.id);
      if (i !== -1 && !state.over) {
        state.over = true;
        io.to(roomId).emit('game-over', { winner: 1 - i, reason: 'opponent disconnected' });
        ROOMS.delete(roomId);
        break;
      }
    }
  });
});

const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
  console.log(`http://localhost:${PORT}`);
});
